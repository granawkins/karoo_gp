import numpy as np
from sympy import sympify

class Tree:
    def __init__(self, id, root, params):
        self.id = id        # The tree's position (index) with the population
        self.root = root    # The np.array that hold's the tree's state
        self.result = params.get('result', {})  # Reports generated by .evaluate
        self.pop_tree_type = params['pop_tree_type']
        self.tree_depth_max = params['tree_depth_max']

    @classmethod
    def generate(cls, log, pause, error, id, tree_type, tree_depth_base, tree_depth_max, functions,
                 terminals, rng):
        '''Generate a new Tree object given starting parameters.'''
        # Several 'fx_..' work together to create the new 'root', or the
        # np.array that defines a tree. Previously these functions all relied on
        # state. Now we store everything in 'roots' and 'params' and pass them
        # around in order.
        root, params = fx_init_tree_initialise(id, tree_type, tree_depth_base)
        params['tree_depth_max'] = tree_depth_max
        params['functions'] = functions
        params['terminals'] = terminals
        tree = cls(id, root, params)
        tree, params = fx_init_root_build(tree, params, rng, error)
        tree, params = fx_init_function_build(tree, params, rng)
        tree, params = fx_init_terminal_build(tree, params, rng)
        tree = fx_data_tree_clean(tree)
        return tree

    def display(self):
        '''Print the full-detail, formatted tree to the console'''
        fx_display_tree(self)

    @property
    def raw_expression(self):
        '''Return the raw (un-sympified) expression'''
        return fx_eval_label(self, 1)

    @property
    def expression(self):
        '''Return the sympified expression'''
        return str(sympify(self.raw_expression))

    def copy(self, id=None):
        '''Return a duplicate, all attributes/state'''
        id = id if id is not None else self.id
        params = dict(pop_tree_type=self.pop_tree_type,
                      tree_depth_max=self.tree_depth_max,
                      result=self.result)
        return Tree(id, np.copy(self.root), params)

    def fitness(self):
        '''Return fitness or -1 if not yet evaluated'''
        if len(self.root) < 12 or len(self.root[12]) < 2 or self.root[12][1] == '':
            raise ValueError(f'Tree {self.id} fitness has not been evaluated')
        else:
            return float(self.root[12][1])

# used by: Population, Tree
def fx_data_tree_clean(tree):

    '''
    This method aesthetically cleans the Tree array, removing redundant data.

    Called by: fx_data_tree_append, fx_evolve_branch_copy

    Arguments required: tree
    '''

    tree.root[0][2:] = ''  # A little clean-up to make things look pretty :)
    tree.root[1][2:] = ''  # Ignore the man behind the curtain!
    tree.root[2][2:] = ''  # Yes, I am a bit OCD ... but you *know* you appreciate clean arrays.

    return tree


# used by: Tree
def fx_init_tree_initialise(TREE_ID, tree_type, tree_depth_base):
    '''
    Assign 13 global variables to the array 'tree'.

    Build the array 'tree' with 13 rows and initally, just 1 column
    of labels. This array will grow horizontally as each new node
    is appended. The values of this array are stored as string
    characters, numbers forced to integers at the point of execution.

    Use of the debug (db) interface mode enables the user to watch
    the genetic operations as they work on the Trees.

    Called by: fx_init_tree_build

    Arguments required: TREE_ID, tree_type, tree_depth_base
    '''
    params = dict(
        # pos 0: a unique identifier for each tree
        pop_TREE_ID = TREE_ID,
        # pos 1: a global constant based upon the initial user setting
        pop_tree_type = tree_type,
        # pos 2: a global variable which conveys 'tree_depth_base' as unique to each new Tree
        pop_tree_depth_base = tree_depth_base,
        # pos 3: unique identifier for each node; this is the INDEX KEY to this array
        pop_NODE_ID = 1,
        # pos 4: depth of each node when committed to the array
        pop_node_depth = 0,
        # pos 5: root, function, or terminal
        pop_node_type = '',
        # pos 6: operator [+, -, *, ...] or terminal [a, b, c, ...]
        pop_node_label = '',
        # pos 7: parent node
        pop_node_parent = '',
        # pos 8: number of nodes attached to each non-terminal node
        pop_node_arity = '',
        # pos 9: child node 1
        pop_node_c1 = '',
        # pos 10: child node 2
        pop_node_c2 = '',
        # pos 11: child node 3 (assumed max of 3 with boolean operator 'if')
        pop_node_c3 = '',
        # pos 12: fitness score following Tree evaluation
        pop_fitness = '',
    )
    tree = np.array([
        ['TREE_ID'], ['tree_type'], ['tree_depth_base'],
        ['NODE_ID'], ['node_depth'], ['node_type'],
        ['node_label'], ['node_parent'], ['node_arity'],
        ['node_c1'], ['node_c2'], ['node_c3'], ['fitness']
    ])
    return tree, params

### Root Node ###
# used by: Tree
def fx_init_root_build(tree, params, rng, error):

    '''
    Build the Root node for the initial population.

    Called by: fx_init_tree_build

    Arguments required: none
    '''

    tree, params = fx_init_function_select(tree, params, rng)  # select the operator for root

    if params['pop_node_arity'] == 1:  # 1 child
        params['pop_node_c1'] = 2
        params['pop_node_c2'] = ''
        params['pop_node_c3'] = ''

    elif params['pop_node_arity'] == 2:  # 2 children
        params['pop_node_c1'] = 2
        params['pop_node_c2'] = 3
        params['pop_node_c3'] = ''

    elif params['pop_node_arity'] == 3:  # 3 children
        params['pop_node_c1'] = 2
        params['pop_node_c2'] = 3
        params['pop_node_c3'] = 4

    else:
        error(f'\n\t\033[31m ERROR! In fx_init_root_build: pop_node_arity = '
              f'{params.pop_node_arity} \033[0;0m')

    params['pop_node_type'] = 'root'
    tree, params = fx_init_node_commit(tree, params)

    return tree, params

### Function Nodes ###
# used by: Tree
def fx_init_function_build(tree, params, rng):

    '''
    Build the Function nodes for the intial population.

    Called by: fx_init_tree_build

    Arguments required: none
    '''

    # increment depth, from 1 through 'tree_depth_base' - 1
    for i in range(1, params['pop_tree_depth_base']):

        params['pop_node_depth'] = i  # increment 'node_depth'

        parent_arity_sum = 0
        prior_sibling_arity = 0  # reset for 'c_buffer' in 'children_link'
        prior_siblings = 0  # reset for 'c_buffer' in 'children_link'

        # increment through all nodes (exclude 0) in array 'tree'
        for j in range(1, len(tree.root[3])):

            # find parent nodes which reside at the prior depth
            if int(tree.root[4][j]) == params['pop_node_depth'] - 1:
                # sum arities of all parent nodes at the prior depth
                parent_arity_sum = parent_arity_sum + int(tree.root[8][j])

                # (do *not* merge these 2 "j" loops or it gets all kinds of messed up)

        # increment through all nodes (exclude 0) in array 'tree'
        for j in range(1, len(tree.root[3])):

            # find parent nodes which reside at the prior depth
            if int(tree.root[4][j]) == params['pop_node_depth'] - 1:

                # increment through each degree of arity for each parent node
                for k in range(1, int(tree.root[8][j]) + 1):
                    # set the parent 'NODE_ID' ...
                    params['pop_node_parent'] = int(tree.root[3][j])
                    tree, params, prior_sibling_arity = fx_init_function_gen(
                        tree, params, parent_arity_sum, prior_sibling_arity,
                        prior_siblings, rng
                    )  # ... generate a Function node
                    # sum sibling nodes (current depth) who will spawn
                    # their own children (cousins? :)
                    prior_siblings = prior_siblings + 1

    return tree, params

# used by: Tree
def fx_init_function_gen(tree, params, parent_arity_sum, prior_sibling_arity,
                         prior_siblings, rng):

    '''
    Generate a single Function node for the initial population.

    Called by fx_init_function_build

    Arguments required: parent_arity_sum, prior_sibling_arity, prior_siblings
    '''

    if params['pop_tree_type'] == 'f':  # user defined as (f)ull
        tree, params = fx_init_function_select(tree, params, rng)  # retrieve a function
        # establish links to children
        fx_init_child_link(tree, params, parent_arity_sum, prior_sibling_arity,
                           prior_siblings)

    elif params['pop_tree_type'] == 'g':  # user defined as (g)row
        rnd = rng.integers(2)

        if rnd == 0:  # randomly selected as Function
            tree, params = fx_init_function_select(tree, params, rng)  # retrieve a function
            # establish links to children
            fx_init_child_link(tree, params, parent_arity_sum, prior_sibling_arity,
                               prior_siblings)

        elif rnd == 1:  # randomly selected as Terminal
            tree, params = fx_init_terminal_select(tree, params, rng)  # retrieve a terminal
            params['pop_node_c1'] = ''
            params['pop_node_c2'] = ''
            params['pop_node_c3'] = ''

    tree, params = fx_init_node_commit(tree, params)  # commit new node to array
    # sum the arity of prior siblings
    prior_sibling_arity = prior_sibling_arity + params['pop_node_arity']

    return tree, params, prior_sibling_arity

# used by: Tree
def fx_init_function_select(tree, params, rng):

    '''
    Define a single Function (operator extracted from the
    associated functions.csv) for the initial population.

    Called by: fx_init_function_gen, fx_init_root_build

    Arguments required: none
    '''

    params['pop_node_type'] = 'func'
    # call the previously loaded .csv which contains all operators
    rnd = rng.integers(0, len(params['functions'][:,0]))
    params['pop_node_label'] = params['functions'][rnd][0]
    params['pop_node_arity'] = int(params['functions'][rnd][1])

    return tree, params

### Terminal Nodes ###
# used by: Tree
def fx_init_terminal_build(tree, params, rng):

    '''
    Build the Terminal nodes for the intial population.

    Called by: fx_init_tree_build

    Arguments required: none
    '''

    # set the final node_depth (same as 'gp.pop_node_depth' + 1)
    params['pop_node_depth'] = params['pop_tree_depth_base']

    # increment through all nodes (exclude 0) in array 'tree'
    for j in range(1, len(tree.root[3])):

        # find parent nodes which reside at the prior depth
        if int(tree.root[4][j]) == params['pop_node_depth'] - 1:

            # increment through each degree of arity for each parent node
            for k in range(1, (int(tree.root[8][j]) + 1)):
                # set the parent 'NODE_ID'  ...
                params['pop_node_parent'] = int(tree.root[3][j])
                tree, params = fx_init_terminal_gen(tree, params, rng)  # ... generate a Terminal node

    return tree, params

# used by: Tree
def fx_init_terminal_gen(tree, params, rng):

    '''
    Generate a single Terminal node for the initial population.

    Called by: fx_init_terminal_build

    Arguments required: none
    '''

    tree, params = fx_init_terminal_select(tree, params, rng)  # retrieve a terminal
    params['pop_node_c1'] = ''
    params['pop_node_c2'] = ''
    params['pop_node_c3'] = ''

    tree, params = fx_init_node_commit(tree, params)  # commit new node to array

    return tree, params

# used by: Tree
def fx_init_terminal_select(tree, params, rng):

    '''
    Define a single Terminal (variable extracted from the top row
    of the associated TRAINING data)

    Called by: fx_init_terminal_gen, fx_init_function_gen

    Arguments required: none
    '''

    params['pop_node_type'] = 'term'
    # call the previously loaded .csv which contains all terminals
    rnd = rng.integers(0, len(params['terminals']) - 1)
    params['pop_node_label'] = params['terminals'][rnd]
    params['pop_node_arity'] = 0

    return tree, params


### The Lovely Children ###
# used by: Tree
def fx_init_child_link(tree, params, parent_arity_sum, prior_sibling_arity, prior_siblings):

    '''
    Link each parent node to its children in the intial population.

    Called by: fx_init_function_gen

    Arguments required: parent_arity_sum, prior_sibling_arity, prior_siblings
    '''

    c_buffer = 0

    # increment through all nodes (exclude 0) in array 'tree'
    for n in range(1, len(tree.root[3])):

        # find all nodes that reside at the prior (parent) 'node_depth'
        if int(tree.root[4][n]) == params['pop_node_depth'] - 1:

            # One algo to rule the world!
            c_buffer = params['pop_NODE_ID'] + (parent_arity_sum + prior_sibling_arity - prior_siblings)

            if params['pop_node_arity'] == 0:  # terminal in a Grow Tree
                params['pop_node_c1'] = ''
                params['pop_node_c2'] = ''
                params['pop_node_c3'] = ''

            elif params['pop_node_arity'] == 1:  # 1 child
                params['pop_node_c1'] = c_buffer
                params['pop_node_c2'] = ''
                params['pop_node_c3'] = ''

            elif params['pop_node_arity'] == 2:  # 2 children
                params['pop_node_c1'] = c_buffer
                params['pop_node_c2'] = c_buffer + 1
                params['pop_node_c3'] = ''

            elif params['pop_node_arity'] == 3:  # 3 children
                params['pop_node_c1'] = c_buffer
                params['pop_node_c2'] = c_buffer + 1
                params['pop_node_c3'] = c_buffer + 2

            # else:
            #     self.log(f'\n\t\033[31m ERROR! In fx_init_child_link: pop_node_arity = {self.pop_node_arity} \033[0;0m')
            #     # consider special instructions for this (pause) - 2019 06/08
            #     self.fx_karoo_pause()

    return tree, params

# used by: Tree
def fx_init_node_commit(tree, params):
    '''
    Commit the values of a new node (root, function, or terminal) to the array 'tree'.

    Called by: fx_init_root_build, fx_init_function_gen, fx_init_terminal_gen

    Arguments required: none
    '''
    tree.root = np.append(tree.root, [
        [params['pop_TREE_ID']], [params['pop_tree_type']], [params['pop_tree_depth_base']],
        [params['pop_NODE_ID']], [params['pop_node_depth']], [params['pop_node_type']],
        [params['pop_node_label']], [params['pop_node_parent']], [params['pop_node_arity']],
        [params['pop_node_c1']], [params['pop_node_c2']], [params['pop_node_c3']], [params['pop_fitness']]
    ], 1)

    params['pop_NODE_ID'] = params['pop_NODE_ID'] + 1

    return tree, params


#+++++++++++++++++++++++++++++++++++++++++++++
#   Methods to Evaluate a Tree               |
#+++++++++++++++++++++++++++++++++++++++++++++

# used by: Tree
def fx_eval_label(tree, node_id):

    '''
    Evaluate all or part of a Tree (starting at node_id) and
    return a raw mutivariate expression ('algo_raw').

    This method is called once per Tree, but may be called at any time
    to prepare an expression for any full or partial (branch) Tree
    contained in 'population'. Pass the starting node for recursion
    via the local variable 'node_id' where the local variable 'tree'
    is a copy of the Tree you desire to evaluate.

    Called by: fx_eval_poly, fx_eval_label (recursively)

    Arguments required: tree, node_id
    '''

    # temp until this can be fixed at data_load
    # if tree[6, node_id] == 'not': tree[6, node_id] = ', not'

    node_id = int(node_id)

    if tree.root[8, node_id] == '0':  # arity of 0 for the pattern '[term]'
        return '(' + tree.root[6, node_id] + ')'  # 'node_label' (function or terminal)

    else:
        # arity of 1 for the explicit pattern 'not [term]'
        if tree.root[8, node_id] == '1':
            return fx_eval_label(tree, tree.root[9, node_id]) + tree.root[6, node_id]

        # arity of 2 for the pattern '[func] [term] [func]'
        elif tree.root[8, node_id] == '2':
            return (fx_eval_label(tree, tree.root[9, node_id]) +
                    tree.root[6, node_id] +
                    fx_eval_label(tree, tree.root[10, node_id]))

        # arity of 3 for the explicit pattern 'if [term] then [term] else [term]'
        elif tree.root[8, node_id] == '3':
            return (tree.root[6, node_id] + fx_eval_label(tree, tree.root[9, node_id]) +
                    ' then ' + fx_eval_label(tree, tree.root[10, node_id]) +
                    ' else ' + fx_eval_label(tree, tree.root[11, node_id]))

#+++++++++++++++++++++++++++++++++++++++++++++
#   Methods to Visualize a Tree              |
#+++++++++++++++++++++++++++++++++++++++++++++
# used by: Tree
def fx_display_tree(tree):

    '''
    Display all or part of a Tree on-screen.

    This method displays all sequential node_ids from 'start' node
    through bottom, within the given tree.

    Called by: fx_karoo_gp, fx_karoo_pause

    Arguments required: tree
    '''

    ind = ''
    print('\n\033[1m\033[36m Tree ID', int(tree.root[0][1]), '\033[0;0m')

    # increment through all possible Tree depths - tested 2016 07/09
    for depth in range(tree.tree_depth_max + 1):
        print('\n', ind, '\033[36m Tree Depth:', depth, 'of',
              tree.root[2][1], '\033[0;0m')

        # increment through all nodes (redundant, I know)
        for node in range(1, len(tree.root[3])):
            if int(tree.root[4][node]) == depth:
                print()
                print(ind, '\033[1m\033[36m NODE:', tree.root[3][node],
                      '\033[0;0m')
                print(ind, '  type:', tree.root[5][node])
                print(ind, '  label:', tree.root[6][node], '\tparent node:',
                      tree.root[7][node])
                print(ind, '  arity:', tree.root[8][node], '\tchild node(s):',
                      tree.root[9][node], tree.root[10][node], tree.root[11][node])

        ind = ind + '\t'

    print()
    # generate the raw and sympified expression for the entire Tree
    print(f'\t\033[36mTree {tree.id} yields (raw): {tree.raw_expression} \033[0;0m\n'
          f'\t\033[36mTree {tree.id} yields (sym):\033[1m {tree.expression} \033[0;0m')
